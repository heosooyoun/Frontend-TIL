CSS 기본문법 

선택자 {
	속성: 속성값;
	속성: 속성값;
}

1) 선택자의 역할: 속성과 값을 지정할 대상을 검색
=> CSS에서 선택자를 사용하는 방법을 잘 배우는 것이 중요!!

2) 속성과 값의 역할: 검색된 대상에 지정될 CSS 명령

<실습>
- color 속성: 글자 색
- font-size 속성: 글자 크기
- font-weight 속성: 글씨 두께

3) 주석
- /* */를 이용 

4. CSS 선언 방식
 1) 인라인(in-line) 방식 
  - HTML 요소의 style 속성에 직접 작성하는 방식
  - 선택자가 필요하지 않음
  - 반복 사용과 유지 보수를 위해서는 이 방법은 비추천

 2) 내장(embedded) 방식
  - html의 <style> 태그 안에 작성하는 방식

 3) 링크(link) 방식
  - html <link> 태그를 이용하여 외부 문서로 css를 불러와 적용하는 방식 
  - 가장 많이 사용되고 추천되는 방식
 
 4) @import 방식
  - @: at
  - @import를 이용해서 외부 문서로 css를 불러와 적용하는 방식
  - link 태그와 다른 점: link 태그는 html에서 css 파일을 불러오는 것, @import는 css에서 외부 css 파일을 가져오는 것(css가 css를 가져오는 것)
  - link 태그를 여러 개 사용하여 css 파일을 불러오면 그 여러 개가 동시에 불러 들어오는데(병렬 호출), import 방식은 1번이 불려지고 난 후에 2번, 그 다음에 3번 이렇게 순서대로 불러들어온다(직렬호출). => 주의해서 사용하기
------------------------------------------------
  
CSS 선택자

1. 전체 선택자
- 모든 요소를 선택
- 사용 방법:　*

2. 태그 선택자
- 태그 이름으로 요소 선택
- 사용 방법:　(태그 이름) -> 앞, 뒤에 다른 기호 없이 사용

3. 클래스 선택자
- html의 class 속성 값이 E인 요소 선택
- 사용 방법: .E => 클래스 명이 E인 태그 선택

4. 아이디 선택자
- html의 id 속성값이 E인 요소 선택
- 사용 방법: #E

5. 복합 선택자

 1) 일치 선택자
  - E와 F를 동시에 만족하는 요소 선택
  - 사용 방법: EF
  - 두 조건을 동시에 만족시키는 요소를 선택
   ex) span.orange -> 태그선택자 + 클래스 선택자 => span 태그이면서 클래스가 orange인 속성을 선택

 2) 자식 선택자
  - E의 자식요소 F를 선택
  - 사용 방법: E >　F -> 앞의 E는 조건, F는 검색으로, E 조건에 맞는 F 요소를 검색하는 것이다.
   ex) ul > .orange -> ul의 자식요소 중 orange라는 클래스 값을 가지고 있는 요소

 3) 후손(하위, 자손) 선택자
  - E의 후손(하위, 자손) 요소 F를 선택
  - 사용 방법: E F (띄어쓰기가 기호로 사용 된다.)
   ex) div .orange : div 태그를 찾아서 그것의 후손인 orange 클래스를 찾으라는 의미


* 후손: 어떠한 태그의 후손이라는 것은 그 태그 범위에 있는 모든 요소를 의미한다. 

<실습- 후손에 대한 설명>
- div태그와 ul태그는 부모 자식 관계, ul태그와 li태그도 부모 자식 관계
 -> div 태그와 li태그는 후손(하위) 조상(상위) 관계
 -> li 태그들 사이의 관계는 형제 요소 (같은 부모를 갖기 때문)
 -> ul 태그와 두 번째 div 태그, p태그, span 태그도 형제 관계
- 어떠한 태그 안의 모든 요소는 후손 요소라고 부를 수 있고, 바로 밑의 요소만 자식 요소라고 부른다. => 자식요소를 후손 요소라고도 부를 수 있다.
- 반대로 어떤 후손 요소의 상위 요소들을 모두 조상 요소라고 부를 수 있고, 바로 위의 조상 요소만 부모 요소라고 한다. => 조상요소가 부모 요소를 포함

 4) 인접 형제 선택자
  - E의 다음 형제 요소 F 하나만 선택
  - 사용 방법: E + F
   ex) .orange + li -> orange라는 클래스 명을 갖고 있는(조건) 요소의 다음 형제로 인접해 있는 li 태그 요소(검색)를 찾는다.

 5) 일반 형제 선택자
  - E의 다음 형제 요소 F 모두 선택 
  - 사용 방법: E ~ F 
   ex) .orange ~ li -> orange라는 클래스 이름을 갖은 요소를 기준으로 일반 형제들 중 다음 li 태그를 찾는다.

6. 가상 클래스 선택자
- 사용 방법-> : 가상 클래스 선택자

 1) Hover
  - E에 마우스(포인터)가 올라가 있는 동안에만 E 선택
  - 사용 방법: E(기본 선택자): hover

 2) Active
  - E를 마우스로 클릭하는 동안에만 E 선택
  - 사용 방법: E:active

 3) Focus
  - E가 포커스 된 동안에만 E 선택 -> 대화형 콘텐츠(input 태그, img 태그, tabindex 속성)에서 사용 가능
   => input 요소에서 많이 사용됨
  - 사용 방법: E:focus
 * 실습에서 padding을 이용할 때 5px 10px 이런 식으로 두 가지로 나누어서 사용하면, 위, 아래 여백은 5px, 좌, 우 여백은 10px을 지정하겠다는 의미

CSS 가상 클래스 선택자
- hover, active, focus처럼 사용자가 어떠한 행동(이벤트)을 했을 때 결과가 나오는 것들은 자바 스크립트가 더 어울린다. -> 이 세 가지를 css에 특이하게 존재하는 개념
- 이제부터 배울 ~child라는 선택자 개념은 생각보다 많이 사용되기 때문에 꼭 기억해 두기

1. first child
- E가 형제 요소 중 첫 번째 요소라면 선택
- 사용 방법: E: first-child
- .fruits li: first-child: fruits라는 클래스 이름을 가진 요소의 후손 중 li 태그를 찾고(조건), 그 중 첫 번째 요소를 찾아라(검색)

2. last child
- E가 형제 요소 중 마지막 요소라면 선택
- 사용 방법: E: last-child
- .fruits li: last-child: fruits라는 클래스 이름을 가진 요소의 후손 중 li 태그를 찾고(조건), 그 중 마지막 요소를 찾아라(검색)

3. Nth child
- E가 형제 요소 중 n 번째 요소라면 선택
- 사용 방법: E: nth-child(n) -> n 키워드 사용 시 0부터 해석
- .fruits li: nth-child(2n): fruits라는 클래스 이름을 가진 요소의 후손 중 li 태그를 찾고(조건), 그 중 2n번째 요소를 찾아라(검색) -> 여기서 0은 0부터 하나씩 증가하는 수
  -> 따라서 n은 2*0=0, 2*1=2, 2*2=4... 이렇게 증가하므로 2, 4 번째만 선택된다.
- .fruits li: nth-child(n+3): 3번째 요소 이후부터 모두 선택된다.

<실습>
 <div  class ="fruits">
         <div >딸기 </div >
         <p >사과 </p >
         <p >망고 </p >
         <span >바나나 </span >
     </div >

.fruits  p:nth-child (1 )
- p 태그가 .fruits의 첫 번째 자식 요소가 아니기 때문에 선택되지 않음
=> 오른쪽에서 왼쪽으로 해석되는 것이라고 생각하기 => 첫 번째 요소를 선택할 것인데, 그 요소의 부모 요소가 fruits여야 하고, 첫 번째 요소는 p태그여야 한다.

* nth child(1)/first child를 사용할 때 주의할 점은 이 두 가지 선택자 모두 어떤 선택자의 모든 후손 선택자 중에서 첫 번째를 선택하는 것이기 때문에 복잡한 html 코드의 경우에서 원하지 않는 것이 선택될 수 있기 때문에 자식선택자(>)를 활용하는 것도 중요하다.

4. nth of type
- E의 타입(태그이름)과 통일한 타입인 형제 요소 중 E가 n번째 요소라면 선택, n 키워드 사용시 0부터 해석
- 사용 방법: E:nth-of-type(n)
- .fruits p:nth-of-type(1): fruits 클래스를 가진 후손 요소 중 p 태그들 중 첫 번째 p 태그

<실습2>
- 딸기 부분만 빨간색 글자로 바꾸고 싶을 때
<ul  class ="fruits">
         <li >오렌지 </li >
         <li  class ="red">딸기 </li >
         <li >망고 </li >
         <li  class ="red">사과 </li >
     </ul >

.fruits  .red:nth-of-type (1 ) {
    color : red ;
}
- 이렇게 하면 아무것도 선택이 되지 않는다 -> nth-of-type은 타입, 태그이름으로 찾는 것인데 .red라고 되어있기 때문이다. 오른쪽부터 해석하면 nth-of-type(1)은 첫 번째 요소를 찾는데 일단은 오렌지 이다. 그리고는 .red로 인해 클래스가 red 여야 하는데 오렌지는 아니기 때문에 아무것도 선택이 되지 않는 것이다. 
=> 클래스와 nth-of-type을 섞어서 사용하지 않기!

5. 부정 선택자
- S가 아닌 E 선택
- 사용 방법: E:not(S)
- s는 새로운 선택자를 입력하면 되고, 그 선택자만 빼고 선택하겠다는 의미
-------------------------------
CSS 가상 요소 선택자
- css를 통해 html에 가상의 요소를 생성할 수 있다.
- 가상 클래스 선택자는 : 이 있고, 가상 요소 선택자는 :: 이 있다.

1. before
- E 요소 내부의 앞에 내용(content)삽입 
- 사용 방법: E::before
* 여러개의 태그들을 한번에 만드는 방법
  ul>li ->ul 태그의 자식으로 li태그를 생성
  ul>li{숫자 1} -> ul 태그의 자식으로 li태그를 생성하되 li 태그의 내용으로 숫자 1을 넣겟다.
  ul>li{숫자 $}*20 -> li태그를 20개 생성(*20)하는데 내용으로 숫자 1부터 20까지 순차적으로() 넣겠다.
- bofore 라는 선택자를 사용하면 content가 매우 중요!! -> content가 아예 존재하지 않는다면 어떠한 속성도 적용되지 않는다. 
- 
★ before, after 선택자와 content는 한몸이다!

2. after
- E 요소 내부의 뒤에 내용(content)삽입 
- 사용 방법: E::after
- before, after의 content에는 텍스트 뿐만 아니라 이미지도 삽입 가능

**원래 before, after 선택자는 콜론(:)이 하나여도 동작을 하도록 만들었다. 하지만 이것은 옛날 버전이고 현재는 :: 이여야 한다. 현재에도 콜론이 하나여도 동작은 하지만 가상 요소 선택자로 구분하기 위해서는 두 개를 쓰는 것이 좋다.

CSS 속성 선택자
- html의 속성(class, id 등)은 Attribute라고 하고 css의 속성(color, font-size 등)은 property라고 한다.

1. attr
- 속성 attr을 포함한 요소 선택
- 사용 방법:[atter]

<실습>
- opacity 속성: 투명도
- 매번 태그마다 이름을 짓기 어렵기 때문에 속성으로 css를 적용시켜 주는 것

2. attr=value
- 속성 attr을 포함하여 속성값이 value인 요소 선택
- 속성과 값을 동시에 사용하면 조금 더 디테일하게 선택할 수 있다.
- 사용 방법:[attr=value]
ex) type=password (=> type=“password”)-> type이 password 인 요소를 선택, 이때 password 부분에 큰 따옴표를 붙이는 것도 되고 생략하는 것도 가능하다.
-----------------------------------------
CSS 속성 선택자

1. attr^=value
- 속성 attr을 포함하여 속성값이 value로 시작하는 요소 선택
- 사용 방법: [attr^=value]

2. attr$=value
- 속성 attr을 포함하여 속성값이 value로 끝나는 요소 선택
- 사용 방법: [attr$=value]

3. 상속
- 조상 요소로부터 하위요소에 css 속성들이 상속될 수도 있다.
- css의 특정 속성들은 조상에 적용하는 css 속성이 하위요소에도 영향을 미칠 수 있다.
- 보통 글자를 다루는 속성들이 상속이 된다.
ex) font: font-size, font-weight, font-size, font-height, font-family
    color, text-align(글자 정렬), text-indent(들여쓰기), text-decoration(밑줄), opacity 등

3.1 강제 속성
- 원래는 상속되지 않는 속성인데 강제로 속성하는 것
- 자식을 제외한 후손에게는 적용되지 않음
 
4. 우선 순위 결정
- 하나의 요소가 여러 선언의 대상이 될 경우, 어떤 선언의 CSS 속성을 우선 적용할지 결정하는 방법

1) 명시도: 명시도 점수가 높은 선언이 우선
2) 선언 순서: 점수가 같은 경우 가장 마지막에 해석되는(늦게 작성한) 선언이 우선
3) 중요도: 명시도는 상속 규칙보다 우선, “!important”rk 적용된 선언방식이 다른 모든 방식보다 우선

(1) !important
- 모든 선언을 무시하고 가장 우선
- 점수: 무한대 pt

(2) 인라인 선언방식
- 인라인 선언(HTML의 style 속성 사용 시) 
- 점수: 1000pt -> 점수가 너무 높아서 나중에 개발할 때 유지 보수가 어려움(덮어쓰기가 안되서)=> 인라인 선언으로 css 적용은 추천하지 않음

(3) 아이디
- 아이디 선택자
- 점수: 100pt

(4) 클래스
- 클래스 선택자
- 점수: 10pt

(5) 태그
- 태그 선택자
- 점수: 1pt

(6) 전체 
- 전체 선택자(*)
- 점수: 0pt

(7) 상속
- 상속받은 속성은 항상 우선하지 않음
- 점수: 계산하지 않음(0점보다 낮은 것)

<실습>
1. .list li .item{ color: red; } : 클래스 선택자 + 태그 선택자 + 클래스 선택자 = 21pt
2. .list li :hover{ color: red; } : 클래스 선택자 + 태그선택자 + (가상)클래스 선택자 = 21pt
3. .box::before{ color: red; } : 클래스 선택자 + (요소)태그 선택자 = 11pt(요소==태그이다)
4. #submit span { color: red; } : 아이디 선택자 + 태그 선택자 = 101pt
5. header .menu li:nth-child(2){ color: red; } : 태그 선택자 + 클래스 선택자 + 태그 선택자+ (가상)클래스 선택자 = 22pt
6. :not(.box){ color: red; } : 클래스 선택자 = 10pt
* 기본적으로 not 부정 선택자는 점수로 계산하지 않는다
